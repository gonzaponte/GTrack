//
// File generated by rootcint at Fri Jan  9 12:45:33 2015

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME gtrackDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "gtrackDict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace GInfo {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void GInfo_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("GInfo", 0 /*version*/, "./src/GTrack.h", 18,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &GInfo_Dictionary, 4);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void GInfo_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOT {
   void GInfocLcLGSensor_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_GInfocLcLGSensor(void *p = 0);
   static void *newArray_GInfocLcLGSensor(Long_t size, void *p);
   static void delete_GInfocLcLGSensor(void *p);
   static void deleteArray_GInfocLcLGSensor(void *p);
   static void destruct_GInfocLcLGSensor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GInfo::GSensor*)
   {
      ::GInfo::GSensor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::GInfo::GSensor >(0);
      static ::ROOT::TGenericClassInfo 
         instance("GInfo::GSensor", ::GInfo::GSensor::Class_Version(), "./src/GTrack.h", 21,
                  typeid(::GInfo::GSensor), DefineBehavior(ptr, ptr),
                  &::GInfo::GSensor::Dictionary, isa_proxy, 4,
                  sizeof(::GInfo::GSensor) );
      instance.SetNew(&new_GInfocLcLGSensor);
      instance.SetNewArray(&newArray_GInfocLcLGSensor);
      instance.SetDelete(&delete_GInfocLcLGSensor);
      instance.SetDeleteArray(&deleteArray_GInfocLcLGSensor);
      instance.SetDestructor(&destruct_GInfocLcLGSensor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GInfo::GSensor*)
   {
      return GenerateInitInstanceLocal((::GInfo::GSensor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GInfo::GSensor*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void GInfocLcLGSlice_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_GInfocLcLGSlice(void *p = 0);
   static void *newArray_GInfocLcLGSlice(Long_t size, void *p);
   static void delete_GInfocLcLGSlice(void *p);
   static void deleteArray_GInfocLcLGSlice(void *p);
   static void destruct_GInfocLcLGSlice(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GInfo::GSlice*)
   {
      ::GInfo::GSlice *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::GInfo::GSlice >(0);
      static ::ROOT::TGenericClassInfo 
         instance("GInfo::GSlice", ::GInfo::GSlice::Class_Version(), "./src/GTrack.h", 36,
                  typeid(::GInfo::GSlice), DefineBehavior(ptr, ptr),
                  &::GInfo::GSlice::Dictionary, isa_proxy, 4,
                  sizeof(::GInfo::GSlice) );
      instance.SetNew(&new_GInfocLcLGSlice);
      instance.SetNewArray(&newArray_GInfocLcLGSlice);
      instance.SetDelete(&delete_GInfocLcLGSlice);
      instance.SetDeleteArray(&deleteArray_GInfocLcLGSlice);
      instance.SetDestructor(&destruct_GInfocLcLGSlice);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GInfo::GSlice*)
   {
      return GenerateInitInstanceLocal((::GInfo::GSlice*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GInfo::GSlice*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void GInfocLcLGPeak_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_GInfocLcLGPeak(void *p = 0);
   static void *newArray_GInfocLcLGPeak(Long_t size, void *p);
   static void delete_GInfocLcLGPeak(void *p);
   static void deleteArray_GInfocLcLGPeak(void *p);
   static void destruct_GInfocLcLGPeak(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GInfo::GPeak*)
   {
      ::GInfo::GPeak *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::GInfo::GPeak >(0);
      static ::ROOT::TGenericClassInfo 
         instance("GInfo::GPeak", ::GInfo::GPeak::Class_Version(), "./src/GTrack.h", 57,
                  typeid(::GInfo::GPeak), DefineBehavior(ptr, ptr),
                  &::GInfo::GPeak::Dictionary, isa_proxy, 4,
                  sizeof(::GInfo::GPeak) );
      instance.SetNew(&new_GInfocLcLGPeak);
      instance.SetNewArray(&newArray_GInfocLcLGPeak);
      instance.SetDelete(&delete_GInfocLcLGPeak);
      instance.SetDeleteArray(&deleteArray_GInfocLcLGPeak);
      instance.SetDestructor(&destruct_GInfocLcLGPeak);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GInfo::GPeak*)
   {
      return GenerateInitInstanceLocal((::GInfo::GPeak*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GInfo::GPeak*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void GInfocLcLGTrack_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_GInfocLcLGTrack(void *p = 0);
   static void *newArray_GInfocLcLGTrack(Long_t size, void *p);
   static void delete_GInfocLcLGTrack(void *p);
   static void deleteArray_GInfocLcLGTrack(void *p);
   static void destruct_GInfocLcLGTrack(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GInfo::GTrack*)
   {
      ::GInfo::GTrack *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::GInfo::GTrack >(0);
      static ::ROOT::TGenericClassInfo 
         instance("GInfo::GTrack", ::GInfo::GTrack::Class_Version(), "./src/GTrack.h", 70,
                  typeid(::GInfo::GTrack), DefineBehavior(ptr, ptr),
                  &::GInfo::GTrack::Dictionary, isa_proxy, 4,
                  sizeof(::GInfo::GTrack) );
      instance.SetNew(&new_GInfocLcLGTrack);
      instance.SetNewArray(&newArray_GInfocLcLGTrack);
      instance.SetDelete(&delete_GInfocLcLGTrack);
      instance.SetDeleteArray(&deleteArray_GInfocLcLGTrack);
      instance.SetDestructor(&destruct_GInfocLcLGTrack);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GInfo::GTrack*)
   {
      return GenerateInitInstanceLocal((::GInfo::GTrack*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GInfo::GTrack*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

      namespace GInfo {
//______________________________________________________________________________
TClass *GSensor::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *GSensor::Class_Name()
{
   return "GInfo::GSensor";
}

//______________________________________________________________________________
const char *GSensor::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSensor*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int GSensor::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSensor*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void GSensor::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSensor*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *GSensor::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSensor*)0x0)->GetClass();
   return fgIsA;
}

} // namespace GInfo
      namespace GInfo {
//______________________________________________________________________________
TClass *GSlice::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *GSlice::Class_Name()
{
   return "GInfo::GSlice";
}

//______________________________________________________________________________
const char *GSlice::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSlice*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int GSlice::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSlice*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void GSlice::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSlice*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *GSlice::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GSlice*)0x0)->GetClass();
   return fgIsA;
}

} // namespace GInfo
      namespace GInfo {
//______________________________________________________________________________
TClass *GPeak::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *GPeak::Class_Name()
{
   return "GInfo::GPeak";
}

//______________________________________________________________________________
const char *GPeak::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GPeak*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int GPeak::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GPeak*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void GPeak::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GPeak*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *GPeak::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GPeak*)0x0)->GetClass();
   return fgIsA;
}

} // namespace GInfo
      namespace GInfo {
//______________________________________________________________________________
TClass *GTrack::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *GTrack::Class_Name()
{
   return "GInfo::GTrack";
}

//______________________________________________________________________________
const char *GTrack::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GTrack*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int GTrack::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GTrack*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void GTrack::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GTrack*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *GTrack::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::GInfo::GTrack*)0x0)->GetClass();
   return fgIsA;
}

} // namespace GInfo
      namespace GInfo {
//______________________________________________________________________________
void GSensor::Streamer(TBuffer &R__b)
{
   // Stream an object of class GInfo::GSensor.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(GInfo::GSensor::Class(),this);
   } else {
      R__b.WriteClassBuffer(GInfo::GSensor::Class(),this);
   }
}

} // namespace GInfo
//______________________________________________________________________________
      namespace GInfo {
void GSensor::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class GInfo::GSensor.
      TClass *R__cl = ::GInfo::GSensor::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ID", &ID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q", &Q);
      TObject::ShowMembers(R__insp);
}

} // namespace GInfo
namespace ROOT {
   // Wrappers around operator new
   static void *new_GInfocLcLGSensor(void *p) {
      return  p ? new(p) ::GInfo::GSensor : new ::GInfo::GSensor;
   }
   static void *newArray_GInfocLcLGSensor(Long_t nElements, void *p) {
      return p ? new(p) ::GInfo::GSensor[nElements] : new ::GInfo::GSensor[nElements];
   }
   // Wrapper around operator delete
   static void delete_GInfocLcLGSensor(void *p) {
      delete ((::GInfo::GSensor*)p);
   }
   static void deleteArray_GInfocLcLGSensor(void *p) {
      delete [] ((::GInfo::GSensor*)p);
   }
   static void destruct_GInfocLcLGSensor(void *p) {
      typedef ::GInfo::GSensor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GInfo::GSensor

      namespace GInfo {
//______________________________________________________________________________
void GSlice::Streamer(TBuffer &R__b)
{
   // Stream an object of class GInfo::GSlice.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(GInfo::GSlice::Class(),this);
   } else {
      R__b.WriteClassBuffer(GInfo::GSlice::Class(),this);
   }
}

} // namespace GInfo
//______________________________________________________________________________
      namespace GInfo {
void GSlice::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class GInfo::GSlice.
      TClass *R__cl = ::GInfo::GSlice::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "E", &E);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q", &Q);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X", &X);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Y", &Y);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Z", &Z);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NSiPMs", &NSiPMs);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*PMTs", &PMTs);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*SiPMs", &SiPMs);
      TObject::ShowMembers(R__insp);
}

} // namespace GInfo
namespace ROOT {
   // Wrappers around operator new
   static void *new_GInfocLcLGSlice(void *p) {
      return  p ? new(p) ::GInfo::GSlice : new ::GInfo::GSlice;
   }
   static void *newArray_GInfocLcLGSlice(Long_t nElements, void *p) {
      return p ? new(p) ::GInfo::GSlice[nElements] : new ::GInfo::GSlice[nElements];
   }
   // Wrapper around operator delete
   static void delete_GInfocLcLGSlice(void *p) {
      delete ((::GInfo::GSlice*)p);
   }
   static void deleteArray_GInfocLcLGSlice(void *p) {
      delete [] ((::GInfo::GSlice*)p);
   }
   static void destruct_GInfocLcLGSlice(void *p) {
      typedef ::GInfo::GSlice current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GInfo::GSlice

      namespace GInfo {
//______________________________________________________________________________
void GPeak::Streamer(TBuffer &R__b)
{
   // Stream an object of class GInfo::GPeak.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(GInfo::GPeak::Class(),this);
   } else {
      R__b.WriteClassBuffer(GInfo::GPeak::Class(),this);
   }
}

} // namespace GInfo
//______________________________________________________________________________
      namespace GInfo {
void GPeak::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class GInfo::GPeak.
      TClass *R__cl = ::GInfo::GPeak::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "type[3]", type);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nslices", &nslices);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Slices", &Slices);
      TObject::ShowMembers(R__insp);
}

} // namespace GInfo
namespace ROOT {
   // Wrappers around operator new
   static void *new_GInfocLcLGPeak(void *p) {
      return  p ? new(p) ::GInfo::GPeak : new ::GInfo::GPeak;
   }
   static void *newArray_GInfocLcLGPeak(Long_t nElements, void *p) {
      return p ? new(p) ::GInfo::GPeak[nElements] : new ::GInfo::GPeak[nElements];
   }
   // Wrapper around operator delete
   static void delete_GInfocLcLGPeak(void *p) {
      delete ((::GInfo::GPeak*)p);
   }
   static void deleteArray_GInfocLcLGPeak(void *p) {
      delete [] ((::GInfo::GPeak*)p);
   }
   static void destruct_GInfocLcLGPeak(void *p) {
      typedef ::GInfo::GPeak current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GInfo::GPeak

      namespace GInfo {
//______________________________________________________________________________
void GTrack::Streamer(TBuffer &R__b)
{
   // Stream an object of class GInfo::GTrack.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(GInfo::GTrack::Class(),this);
   } else {
      R__b.WriteClassBuffer(GInfo::GTrack::Class(),this);
   }
}

} // namespace GInfo
//______________________________________________________________________________
      namespace GInfo {
void GTrack::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class GInfo::GTrack.
      TClass *R__cl = ::GInfo::GTrack::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "E", &E);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q", &Q);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "S1", &S1);
      R__insp.InspectMember(S1, "S1.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "S2", &S2);
      R__insp.InspectMember(S2, "S2.");
      TObject::ShowMembers(R__insp);
}

} // namespace GInfo
namespace ROOT {
   // Wrappers around operator new
   static void *new_GInfocLcLGTrack(void *p) {
      return  p ? new(p) ::GInfo::GTrack : new ::GInfo::GTrack;
   }
   static void *newArray_GInfocLcLGTrack(Long_t nElements, void *p) {
      return p ? new(p) ::GInfo::GTrack[nElements] : new ::GInfo::GTrack[nElements];
   }
   // Wrapper around operator delete
   static void delete_GInfocLcLGTrack(void *p) {
      delete ((::GInfo::GTrack*)p);
   }
   static void deleteArray_GInfocLcLGTrack(void *p) {
      delete [] ((::GInfo::GTrack*)p);
   }
   static void destruct_GInfocLcLGTrack(void *p) {
      typedef ::GInfo::GTrack current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GInfo::GTrack

namespace ROOT {
   void maplEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEintcOdoublegR_Dictionary();
   static void *new_maplEintcOdoublegR(void *p = 0);
   static void *newArray_maplEintcOdoublegR(Long_t size, void *p);
   static void delete_maplEintcOdoublegR(void *p);
   static void deleteArray_maplEintcOdoublegR(void *p);
   static void destruct_maplEintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<int,double>*)
   {
      map<int,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<int,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<int,double>", -2, "/Applications/root/cint/cint/lib/prec_stl/map", 63,
                  typeid(map<int,double>), DefineBehavior(ptr, ptr),
                  0, &maplEintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(map<int,double>) );
      instance.SetNew(&new_maplEintcOdoublegR);
      instance.SetNewArray(&newArray_maplEintcOdoublegR);
      instance.SetDelete(&delete_maplEintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_maplEintcOdoublegR);
      instance.SetDestructor(&destruct_maplEintcOdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<int,double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<int,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEintcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const map<int,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEintcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<int,double> : new map<int,double>;
   }
   static void *newArray_maplEintcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<int,double>[nElements] : new map<int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEintcOdoublegR(void *p) {
      delete ((map<int,double>*)p);
   }
   static void deleteArray_maplEintcOdoublegR(void *p) {
      delete [] ((map<int,double>*)p);
   }
   static void destruct_maplEintcOdoublegR(void *p) {
      typedef map<int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<int,double>

namespace ROOT {
   void vectorlEGInfocLcLGSensorgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEGInfocLcLGSensorgR_Dictionary();
   static void *new_vectorlEGInfocLcLGSensorgR(void *p = 0);
   static void *newArray_vectorlEGInfocLcLGSensorgR(Long_t size, void *p);
   static void delete_vectorlEGInfocLcLGSensorgR(void *p);
   static void deleteArray_vectorlEGInfocLcLGSensorgR(void *p);
   static void destruct_vectorlEGInfocLcLGSensorgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<GInfo::GSensor>*)
   {
      vector<GInfo::GSensor> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<GInfo::GSensor>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<GInfo::GSensor>", -2, "/Applications/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<GInfo::GSensor>), DefineBehavior(ptr, ptr),
                  0, &vectorlEGInfocLcLGSensorgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<GInfo::GSensor>) );
      instance.SetNew(&new_vectorlEGInfocLcLGSensorgR);
      instance.SetNewArray(&newArray_vectorlEGInfocLcLGSensorgR);
      instance.SetDelete(&delete_vectorlEGInfocLcLGSensorgR);
      instance.SetDeleteArray(&deleteArray_vectorlEGInfocLcLGSensorgR);
      instance.SetDestructor(&destruct_vectorlEGInfocLcLGSensorgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<GInfo::GSensor> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<GInfo::GSensor>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEGInfocLcLGSensorgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<GInfo::GSensor>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEGInfocLcLGSensorgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<GInfo::GSensor> : new vector<GInfo::GSensor>;
   }
   static void *newArray_vectorlEGInfocLcLGSensorgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<GInfo::GSensor>[nElements] : new vector<GInfo::GSensor>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEGInfocLcLGSensorgR(void *p) {
      delete ((vector<GInfo::GSensor>*)p);
   }
   static void deleteArray_vectorlEGInfocLcLGSensorgR(void *p) {
      delete [] ((vector<GInfo::GSensor>*)p);
   }
   static void destruct_vectorlEGInfocLcLGSensorgR(void *p) {
      typedef vector<GInfo::GSensor> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<GInfo::GSensor>

namespace ROOT {
   void vectorlEGInfocLcLGSlicegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEGInfocLcLGSlicegR_Dictionary();
   static void *new_vectorlEGInfocLcLGSlicegR(void *p = 0);
   static void *newArray_vectorlEGInfocLcLGSlicegR(Long_t size, void *p);
   static void delete_vectorlEGInfocLcLGSlicegR(void *p);
   static void deleteArray_vectorlEGInfocLcLGSlicegR(void *p);
   static void destruct_vectorlEGInfocLcLGSlicegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<GInfo::GSlice>*)
   {
      vector<GInfo::GSlice> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<GInfo::GSlice>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<GInfo::GSlice>", -2, "/Applications/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<GInfo::GSlice>), DefineBehavior(ptr, ptr),
                  0, &vectorlEGInfocLcLGSlicegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<GInfo::GSlice>) );
      instance.SetNew(&new_vectorlEGInfocLcLGSlicegR);
      instance.SetNewArray(&newArray_vectorlEGInfocLcLGSlicegR);
      instance.SetDelete(&delete_vectorlEGInfocLcLGSlicegR);
      instance.SetDeleteArray(&deleteArray_vectorlEGInfocLcLGSlicegR);
      instance.SetDestructor(&destruct_vectorlEGInfocLcLGSlicegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<GInfo::GSlice> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<GInfo::GSlice>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEGInfocLcLGSlicegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<GInfo::GSlice>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEGInfocLcLGSlicegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<GInfo::GSlice> : new vector<GInfo::GSlice>;
   }
   static void *newArray_vectorlEGInfocLcLGSlicegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<GInfo::GSlice>[nElements] : new vector<GInfo::GSlice>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEGInfocLcLGSlicegR(void *p) {
      delete ((vector<GInfo::GSlice>*)p);
   }
   static void deleteArray_vectorlEGInfocLcLGSlicegR(void *p) {
      delete [] ((vector<GInfo::GSlice>*)p);
   }
   static void destruct_vectorlEGInfocLcLGSlicegR(void *p) {
      typedef vector<GInfo::GSlice> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<GInfo::GSlice>

namespace ROOT {
   void vectorlEmaplEintcOdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEmaplEintcOdoublegRsPgR_Dictionary();
   static void *new_vectorlEmaplEintcOdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEmaplEintcOdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEmaplEintcOdoublegRsPgR(void *p);
   static void deleteArray_vectorlEmaplEintcOdoublegRsPgR(void *p);
   static void destruct_vectorlEmaplEintcOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<map<int,double> >*)
   {
      vector<map<int,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<map<int,double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<map<int,double> >", -2, "/Applications/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<map<int,double> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEmaplEintcOdoublegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<map<int,double> >) );
      instance.SetNew(&new_vectorlEmaplEintcOdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEmaplEintcOdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEmaplEintcOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmaplEintcOdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEmaplEintcOdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<map<int,double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<map<int,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEmaplEintcOdoublegRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<map<int,double> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmaplEintcOdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<map<int,double> > : new vector<map<int,double> >;
   }
   static void *newArray_vectorlEmaplEintcOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<map<int,double> >[nElements] : new vector<map<int,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmaplEintcOdoublegRsPgR(void *p) {
      delete ((vector<map<int,double> >*)p);
   }
   static void deleteArray_vectorlEmaplEintcOdoublegRsPgR(void *p) {
      delete [] ((vector<map<int,double> >*)p);
   }
   static void destruct_vectorlEmaplEintcOdoublegRsPgR(void *p) {
      typedef vector<map<int,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<map<int,double> >

/********************************************************
* gtrackDict.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtablegtrackDict();

extern "C" void G__set_cpp_environmentgtrackDict() {
  G__cpp_reset_tagtablegtrackDict();
}
#include <new>
extern "C" int G__cpp_dllrevgtrackDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* GInfo */

/* GInfo::GSensor */
static int G__gtrackDict_426_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GSensor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GSensor[n];
     } else {
       p = new((void*) gvp) GInfo::GSensor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GSensor;
     } else {
       p = new((void*) gvp) GInfo::GSensor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GSensor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new GInfo::GSensor((int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) GInfo::GSensor((int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((GInfo::GSensor*) G__getstructoffset())->X());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((GInfo::GSensor*) G__getstructoffset())->Y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) GInfo::GSensor::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GSensor::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) GInfo::GSensor::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      GInfo::GSensor::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((GInfo::GSensor*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GSensor::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GSensor::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GSensor::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_426_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GSensor::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__gtrackDict_426_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GInfo::GSensor* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GInfo::GSensor(*(GInfo::GSensor*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GInfo::GSensor G__TGInfocLcLGSensor;
static int G__gtrackDict_426_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GInfo::GSensor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GInfo::GSensor*) (soff+(sizeof(GInfo::GSensor)*i)))->~G__TGInfocLcLGSensor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GInfo::GSensor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GInfo::GSensor*) (soff))->~G__TGInfocLcLGSensor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__gtrackDict_426_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GSensor* dest = (GInfo::GSensor*) G__getstructoffset();
   *dest = *(GInfo::GSensor*) libp->para[0].ref;
   const GInfo::GSensor& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GInfo::GSlice */
static int G__gtrackDict_427_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GSlice* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GSlice[n];
     } else {
       p = new((void*) gvp) GInfo::GSlice[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GSlice;
     } else {
       p = new((void*) gvp) GInfo::GSlice;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GSlice* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new GInfo::GSlice(
*((map<int,double>*) G__int(libp->para[0])), *((map<int,double>*) G__int(libp->para[1]))
, (double) G__double(libp->para[2]));
   } else {
     p = new((void*) gvp) GInfo::GSlice(
*((map<int,double>*) G__int(libp->para[0])), *((map<int,double>*) G__int(libp->para[1]))
, (double) G__double(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) GInfo::GSlice::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GSlice::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) GInfo::GSlice::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      GInfo::GSlice::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((GInfo::GSlice*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GSlice::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GSlice::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GSlice::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_427_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GSlice::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__gtrackDict_427_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GInfo::GSlice* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GInfo::GSlice(*(GInfo::GSlice*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GInfo::GSlice G__TGInfocLcLGSlice;
static int G__gtrackDict_427_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GInfo::GSlice*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GInfo::GSlice*) (soff+(sizeof(GInfo::GSlice)*i)))->~G__TGInfocLcLGSlice();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GInfo::GSlice*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GInfo::GSlice*) (soff))->~G__TGInfocLcLGSlice();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__gtrackDict_427_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GSlice* dest = (GInfo::GSlice*) G__getstructoffset();
   *dest = *(GInfo::GSlice*) libp->para[0].ref;
   const GInfo::GSlice& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* map<int,double,less<int>,allocator<pair<const int,double> > > */
static int G__gtrackDict_430_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<int,double,less<int>,allocator<pair<const int,double> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<int,double,less<int>,allocator<pair<const int,double> > >[n];
     } else {
       p = new((void*) gvp) map<int,double,less<int>,allocator<pair<const int,double> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<int,double,less<int>,allocator<pair<const int,double> > >;
     } else {
       p = new((void*) gvp) map<int,double,less<int>,allocator<pair<const int,double> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<int,double,less<int>,allocator<pair<const int,double> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<int,double,less<int>,allocator<pair<const int,double> > >(*((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) map<int,double,less<int>,allocator<pair<const int,double> > >(*((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<int,double,less<int>,allocator<pair<const int,double> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<int,double,less<int>,allocator<pair<const int,double> > >(*((map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) map<int,double,less<int>,allocator<pair<const int,double> > >(*((map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<int,double,less<int>,allocator<pair<const int,double> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<int,double,less<int>,allocator<pair<const int,double> > >(*(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) map<int,double,less<int>,allocator<pair<const int,double> > >(*(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<int,double,less<int>,allocator<pair<const int,double> > >& obj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->operator=(*(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->begin();
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->end();
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->rbegin();
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->rend();
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->operator[](*(int*) G__Intref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         pair<map<int,double,less<int>,allocator<pair<const int,double> > >::iterator,bool>* pobj;
         pair<map<int,double,less<int>,allocator<pair<const int,double> > >::iterator,bool> xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->insert(*(map<int,double,less<int>,allocator<pair<const int,double> > >::value_type*) libp->para[0].ref);
         pobj = new pair<map<int,double,less<int>,allocator<pair<const int,double> > >::iterator,bool>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->insert(*((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[0])), *(map<int,double,less<int>,allocator<pair<const int,double> > >::value_type*) libp->para[1].ref);
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->insert(*((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->insert(*((map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->erase(*((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->erase(*(int*) G__Intref(&libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->erase(*((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[0])), *((map<int,double,less<int>,allocator<pair<const int,double> > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->swap(*(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->find(*(int*) G__Intref(&libp->para[0]));
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->count(*(int*) G__Intref(&libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->lower_bound(*(int*) G__Intref(&libp->para[0]));
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_430_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator* pobj;
         map<int,double,less<int>,allocator<pair<const int,double> > >::iterator xobj = ((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__getstructoffset())->upper_bound(*(int*) G__Intref(&libp->para[0]));
         pobj = new map<int,double,less<int>,allocator<pair<const int,double> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef map<int,double,less<int>,allocator<pair<const int,double> > > G__TmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR;
static int G__gtrackDict_430_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (map<int,double,less<int>,allocator<pair<const int,double> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((map<int,double,less<int>,allocator<pair<const int,double> > >*) (soff+(sizeof(map<int,double,less<int>,allocator<pair<const int,double> > >)*i)))->~G__TmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (map<int,double,less<int>,allocator<pair<const int,double> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((map<int,double,less<int>,allocator<pair<const int,double> > >*) (soff))->~G__TmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GInfo::GPeak */
static int G__gtrackDict_435_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GPeak* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GPeak[n];
     } else {
       p = new((void*) gvp) GInfo::GPeak[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GPeak;
     } else {
       p = new((void*) gvp) GInfo::GPeak;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) GInfo::GPeak::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GPeak::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) GInfo::GPeak::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      GInfo::GPeak::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((GInfo::GPeak*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GPeak::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GPeak::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GPeak::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_435_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GPeak::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__gtrackDict_435_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GInfo::GPeak* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GInfo::GPeak(*(GInfo::GPeak*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GInfo::GPeak G__TGInfocLcLGPeak;
static int G__gtrackDict_435_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GInfo::GPeak*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GInfo::GPeak*) (soff+(sizeof(GInfo::GPeak)*i)))->~G__TGInfocLcLGPeak();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GInfo::GPeak*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GInfo::GPeak*) (soff))->~G__TGInfocLcLGPeak();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__gtrackDict_435_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GPeak* dest = (GInfo::GPeak*) G__getstructoffset();
   *dest = *(GInfo::GPeak*) libp->para[0].ref;
   const GInfo::GPeak& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GInfo::GTrack */
static int G__gtrackDict_436_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GTrack* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GTrack[n];
     } else {
       p = new((void*) gvp) GInfo::GTrack[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GInfo::GTrack;
     } else {
       p = new((void*) gvp) GInfo::GTrack;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) GInfo::GTrack::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GTrack::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) GInfo::GTrack::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      GInfo::GTrack::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((GInfo::GTrack*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GTrack::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GTrack::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) GInfo::GTrack::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_436_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) GInfo::GTrack::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__gtrackDict_436_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GInfo::GTrack* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GInfo::GTrack(*(GInfo::GTrack*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GInfo::GTrack G__TGInfocLcLGTrack;
static int G__gtrackDict_436_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GInfo::GTrack*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GInfo::GTrack*) (soff+(sizeof(GInfo::GTrack)*i)))->~G__TGInfocLcLGTrack();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GInfo::GTrack*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GInfo::GTrack*) (soff))->~G__TGInfocLcLGTrack();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__gtrackDict_436_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GInfo::GTrack* dest = (GInfo::GTrack*) G__getstructoffset();
   *dest = *(GInfo::GTrack*) libp->para[0].ref;
   const GInfo::GTrack& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > > */
static int G__gtrackDict_438_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reference obj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->at((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_reference obj = ((const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->at((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator* pobj;
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator xobj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->begin();
         pobj = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator* pobj;
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator xobj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->end();
         pobj = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator* pobj;
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator xobj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->rbegin();
         pobj = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator* pobj;
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator xobj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->rend();
         pobj = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->resize((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->resize((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]), *((map<int,double,less<int>,allocator<pair<const int,double> > >*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reference obj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->operator[]((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_reference obj = ((const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->operator[]((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >[n];
     } else {
       p = new((void*) gvp) vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >;
     } else {
       p = new((void*) gvp) vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]), *(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]), *(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >(*(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >(*(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator*) G__int(libp->para[0])), *((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator*) G__int(libp->para[0])), *((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >& obj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->operator=(*(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->reserve((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<int,double,less<int>,allocator<pair<const int,double> > >& obj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<int,double,less<int>,allocator<pair<const int,double> > >& obj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->push_back(*(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->swap(*(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator* pobj;
         vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator xobj = ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->insert(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator*) G__int(libp->para[0])), *(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[1].ref);
         pobj = new vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->insert(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator*) G__int(libp->para[0])), *((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator*) G__int(libp->para[1]))
, *((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->insert(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator*) G__int(libp->para[0])), (vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type) G__int(libp->para[1])
, *(map<int,double,less<int>,allocator<pair<const int,double> > >*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->erase(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->erase(*((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator*) G__int(libp->para[0])), *((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_438_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > > G__TvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR;
static int G__gtrackDict_438_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) (soff+(sizeof(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >)*i)))->~G__TvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*) (soff))->~G__TvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<GInfo::GSensor,allocator<GInfo::GSensor> > */
static int G__gtrackDict_442_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reference obj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->at((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_reference obj = ((const vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->at((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator* pobj;
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator xobj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->begin();
         pobj = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator* pobj;
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator xobj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->end();
         pobj = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator* pobj;
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator xobj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->rbegin();
         pobj = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator* pobj;
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator xobj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->rend();
         pobj = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->resize((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->resize((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]), *((GInfo::GSensor*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reference obj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->operator[]((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_reference obj = ((const vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->operator[]((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSensor,allocator<GInfo::GSensor> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >[n];
     } else {
       p = new((void*) gvp) vector<GInfo::GSensor,allocator<GInfo::GSensor> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >;
     } else {
       p = new((void*) gvp) vector<GInfo::GSensor,allocator<GInfo::GSensor> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSensor,allocator<GInfo::GSensor> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]), *(GInfo::GSensor*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<GInfo::GSensor,allocator<GInfo::GSensor> >((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]), *(GInfo::GSensor*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<GInfo::GSensor,allocator<GInfo::GSensor> >((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSensor,allocator<GInfo::GSensor> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >(*(vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<GInfo::GSensor,allocator<GInfo::GSensor> >(*(vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSensor,allocator<GInfo::GSensor> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator*) G__int(libp->para[0])), *((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<GInfo::GSensor,allocator<GInfo::GSensor> >(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator*) G__int(libp->para[0])), *((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<GInfo::GSensor,allocator<GInfo::GSensor> >& obj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->operator=(*(vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->reserve((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const GInfo::GSensor& obj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const GInfo::GSensor& obj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->push_back(*(GInfo::GSensor*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->swap(*(vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator* pobj;
         vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator xobj = ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->insert(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator*) G__int(libp->para[0])), *(GInfo::GSensor*) libp->para[1].ref);
         pobj = new vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->insert(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator*) G__int(libp->para[0])), *((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator*) G__int(libp->para[1]))
, *((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->insert(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator*) G__int(libp->para[0])), (vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type) G__int(libp->para[1])
, *(GInfo::GSensor*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->erase(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->erase(*((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator*) G__int(libp->para[0])), *((vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_442_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<GInfo::GSensor,allocator<GInfo::GSensor> > G__TvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR;
static int G__gtrackDict_442_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) (soff+(sizeof(vector<GInfo::GSensor,allocator<GInfo::GSensor> >)*i)))->~G__TvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<GInfo::GSensor,allocator<GInfo::GSensor> >*) (soff))->~G__TvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<GInfo::GSlice,allocator<GInfo::GSlice> > */
static int G__gtrackDict_446_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reference obj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->at((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_reference obj = ((const vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->at((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator* pobj;
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator xobj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->begin();
         pobj = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator* pobj;
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator xobj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->end();
         pobj = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator* pobj;
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator xobj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->rbegin();
         pobj = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator* pobj;
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator xobj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->rend();
         pobj = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->resize((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->resize((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]), *((GInfo::GSlice*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reference obj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->operator[]((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_reference obj = ((const vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->operator[]((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSlice,allocator<GInfo::GSlice> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >[n];
     } else {
       p = new((void*) gvp) vector<GInfo::GSlice,allocator<GInfo::GSlice> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >;
     } else {
       p = new((void*) gvp) vector<GInfo::GSlice,allocator<GInfo::GSlice> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSlice,allocator<GInfo::GSlice> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]), *(GInfo::GSlice*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<GInfo::GSlice,allocator<GInfo::GSlice> >((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]), *(GInfo::GSlice*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<GInfo::GSlice,allocator<GInfo::GSlice> >((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSlice,allocator<GInfo::GSlice> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >(*(vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<GInfo::GSlice,allocator<GInfo::GSlice> >(*(vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<GInfo::GSlice,allocator<GInfo::GSlice> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator*) G__int(libp->para[0])), *((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<GInfo::GSlice,allocator<GInfo::GSlice> >(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator*) G__int(libp->para[0])), *((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<GInfo::GSlice,allocator<GInfo::GSlice> >& obj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->operator=(*(vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->reserve((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const GInfo::GSlice& obj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const GInfo::GSlice& obj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->push_back(*(GInfo::GSlice*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->swap(*(vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator* pobj;
         vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator xobj = ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->insert(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator*) G__int(libp->para[0])), *(GInfo::GSlice*) libp->para[1].ref);
         pobj = new vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->insert(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator*) G__int(libp->para[0])), *((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator*) G__int(libp->para[1]))
, *((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->insert(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator*) G__int(libp->para[0])), (vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type) G__int(libp->para[1])
, *(GInfo::GSlice*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->erase(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->erase(*((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator*) G__int(libp->para[0])), *((vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__gtrackDict_446_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<GInfo::GSlice,allocator<GInfo::GSlice> > G__TvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR;
static int G__gtrackDict_446_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) (soff+(sizeof(vector<GInfo::GSlice,allocator<GInfo::GSlice> >)*i)))->~G__TvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<GInfo::GSlice,allocator<GInfo::GSlice> >*) (soff))->~G__TvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* GInfo */

/* GInfo::GSensor */

/* GInfo::GSlice */

/* map<int,double,less<int>,allocator<pair<const int,double> > > */

/* GInfo::GPeak */

/* GInfo::GTrack */

/* vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > > */

/* vector<GInfo::GSensor,allocator<GInfo::GSensor> > */

/* vector<GInfo::GSlice,allocator<GInfo::GSlice> > */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncgtrackDict {
 public:
  G__Sizep2memfuncgtrackDict(): p(&G__Sizep2memfuncgtrackDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncgtrackDict::*p)();
};

size_t G__get_sizep2memfuncgtrackDict()
{
  G__Sizep2memfuncgtrackDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritancegtrackDict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor))) {
     GInfo::GSensor *G__Lderived;
     G__Lderived=(GInfo::GSensor*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor),G__get_linked_tagnum(&G__gtrackDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice))) {
     GInfo::GSlice *G__Lderived;
     G__Lderived=(GInfo::GSlice*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice),G__get_linked_tagnum(&G__gtrackDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak))) {
     GInfo::GPeak *G__Lderived;
     G__Lderived=(GInfo::GPeak*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak),G__get_linked_tagnum(&G__gtrackDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack))) {
     GInfo::GTrack *G__Lderived;
     G__Lderived=(GInfo::GTrack*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack),G__get_linked_tagnum(&G__gtrackDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetablegtrackDict() {

   /* Setting up typedef entry */
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<int,double>",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_type",105,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("mapped_type",100,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__gtrackDictLN_pairlEintcOdoublegR),0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_compare",117,G__get_linked_tagnum(&G__gtrackDictLN_lesslEintgR),0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("allocator_type",117,G__get_linked_tagnum(&G__gtrackDictLN_allocatorlEpairlEconstsPintcOdoublegRsPgR),0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLreverse_iterator),256,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<int,double,less<int> >",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::map<int,double> >",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<map<int,double> >",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),256,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),1,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),257,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<map<int,double,less<int>,allocator<pair<const int,double> > > >",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<GInfo::GSensor>",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor),256,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor),1,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor),257,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<GInfo::GSlice>",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice),256,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice),1,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice),257,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* GInfo */
static void G__setup_memvarGInfo(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfo));
   {
   }
   G__tag_memvar_reset();
}


   /* GInfo::GSensor */
static void G__setup_memvarGInfocLcLGSensor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor));
   { GInfo::GSensor *p; p=(GInfo::GSensor*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q)-(long)(p)),100,0,0,-1,-1,-1,1,"Q=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* GInfo::GSlice */
static void G__setup_memvarGInfocLcLGSlice(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice));
   { GInfo::GSlice *p; p=(GInfo::GSlice*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),100,0,0,-1,-1,-1,1,"E=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q)-(long)(p)),100,0,0,-1,-1,-1,1,"Q=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),100,0,0,-1,-1,-1,1,"X=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),100,0,0,-1,-1,-1,1,"Y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),100,0,0,-1,-1,-1,1,"Z=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NSiPMs)-(long)(p)),105,0,0,-1,-1,-1,1,"NSiPMs=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PMTs)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TObjArray),-1,-1,1,"PMTs=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiPMs)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TObjArray),-1,-1,1,"SiPMs=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* map<int,double,less<int>,allocator<pair<const int,double> > > */
static void G__setup_memvarmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   { map<int,double,less<int>,allocator<pair<const int,double> > > *p; p=(map<int,double,less<int>,allocator<pair<const int,double> > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* GInfo::GPeak */
static void G__setup_memvarGInfocLcLGPeak(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak));
   { GInfo::GPeak *p; p=(GInfo::GPeak*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->type)-(long)(p)),99,0,0,-1,-1,-1,1,"type[3]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nslices)-(long)(p)),105,0,0,-1,-1,-1,1,"nslices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Slices)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TObjArray),-1,-1,1,"Slices=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* GInfo::GTrack */
static void G__setup_memvarGInfocLcLGTrack(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack));
   { GInfo::GTrack *p; p=(GInfo::GTrack*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),100,0,0,-1,-1,-1,1,"E=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q)-(long)(p)),100,0,0,-1,-1,-1,1,"Q=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->S1)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak),-1,-1,1,"S1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->S2)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak),-1,-1,1,"S2=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__gtrackDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > > */
static void G__setup_memvarvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   { vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > > *p; p=(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<GInfo::GSensor,allocator<GInfo::GSensor> > */
static void G__setup_memvarvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   { vector<GInfo::GSensor,allocator<GInfo::GSensor> > *p; p=(vector<GInfo::GSensor,allocator<GInfo::GSensor> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<GInfo::GSlice,allocator<GInfo::GSlice> > */
static void G__setup_memvarvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   { vector<GInfo::GSlice,allocator<GInfo::GSlice> > *p; p=(vector<GInfo::GSlice,allocator<GInfo::GSlice> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvargtrackDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncGInfo(void) {
   /* GInfo */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfo));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGInfocLcLGSensor(void) {
   /* GInfo::GSensor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor));
   G__memfunc_setup("GSensor",705,G__gtrackDict_426_0_1, 105, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSensor",705,G__gtrackDict_426_0_2, 105, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), -1, 0, 2, 1, 1, 0, 
"i - - 0 - sensor_id d - - 0 - sensor_q", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("X",88,G__gtrackDict_426_0_3, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Y",89,G__gtrackDict_426_0_4, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__gtrackDict_426_0_5, 85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&GInfo::GSensor::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__gtrackDict_426_0_6, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GSensor::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__gtrackDict_426_0_7, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&GInfo::GSensor::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__gtrackDict_426_0_8, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&GInfo::GSensor::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__gtrackDict_426_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__gtrackDict_426_0_13, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GSensor::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__gtrackDict_426_0_14, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GSensor::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__gtrackDict_426_0_15, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GSensor::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__gtrackDict_426_0_16, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GSensor::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("GSensor", 705, G__gtrackDict_426_0_17, (int) ('i'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), -1, 0, 1, 1, 1, 0, "u 'GInfo::GSensor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSensor", 831, G__gtrackDict_426_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__gtrackDict_426_0_19, (int) ('u'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), -1, 1, 1, 1, 1, 0, "u 'GInfo::GSensor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGInfocLcLGSlice(void) {
   /* GInfo::GSlice */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice));
   G__memfunc_setup("GSlice",567,G__gtrackDict_427_0_1, 105, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSlice",567,G__gtrackDict_427_0_2, 105, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), -1, 0, 3, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >' 'map<int,double>' 0 - cathode u 'map<int,double,less<int>,allocator<pair<const int,double> > >' 'map<int,double>' 0 - anode "
"d - - 0 - z", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__gtrackDict_427_0_3, 85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&GInfo::GSlice::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__gtrackDict_427_0_4, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GSlice::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__gtrackDict_427_0_5, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&GInfo::GSlice::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__gtrackDict_427_0_6, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&GInfo::GSlice::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__gtrackDict_427_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__gtrackDict_427_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GSlice::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__gtrackDict_427_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GSlice::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__gtrackDict_427_0_13, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GSlice::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__gtrackDict_427_0_14, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GSlice::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("GSlice", 567, G__gtrackDict_427_0_15, (int) ('i'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), -1, 0, 1, 1, 1, 0, "u 'GInfo::GSlice' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSlice", 693, G__gtrackDict_427_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__gtrackDict_427_0_17, (int) ('u'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), -1, 1, 1, 1, 1, 0, "u 'GInfo::GSlice' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR(void) {
   /* map<int,double,less<int>,allocator<pair<const int,double> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR));
   G__memfunc_setup("map<int,double,less<int>,allocator<pair<const int,double> > >",5720,G__gtrackDict_430_0_1, 105, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<int,double,less<int>,allocator<pair<const int,double> > >",5720,G__gtrackDict_430_0_2, 105, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - first u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<int,double,less<int>,allocator<pair<const int,double> > >",5720,G__gtrackDict_430_0_3, 105, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator' - 0 - first u 'map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<int,double,less<int>,allocator<pair<const int,double> > >",5720,G__gtrackDict_430_0_4, 105, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__gtrackDict_430_0_5, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__gtrackDict_430_0_6, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__gtrackDict_430_0_7, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__gtrackDict_430_0_8, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__gtrackDict_430_0_9, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__gtrackDict_430_0_10, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__gtrackDict_430_0_11, 107, -1, G__defined_typename("map<int,double,less<int>,allocator<pair<const int,double> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__gtrackDict_430_0_12, 107, -1, G__defined_typename("map<int,double,less<int>,allocator<pair<const int,double> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_430_0_13, 100, -1, -1, 1, 1, 1, 1, 0, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_430_0_14, 117, G__get_linked_tagnum(&G__gtrackDictLN_pairlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiteratorcOboolgR), -1, 0, 1, 1, 1, 0, "u 'pair<int,double>' 'map<int,double,less<int>,allocator<pair<const int,double> > >::value_type' 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_430_0_15, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - position u 'pair<int,double>' 'map<int,double,less<int>,allocator<pair<const int,double> > >::value_type' 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_430_0_16, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - first u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_430_0_17, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator' - 0 - first u 'map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_430_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_430_0_19, 107, -1, G__defined_typename("map<int,double,less<int>,allocator<pair<const int,double> > >::size_type"), 0, 1, 1, 1, 0, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_430_0_20, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - first u 'map<int,double,less<int>,allocator<pair<const int,double> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__gtrackDict_430_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 1 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__gtrackDict_430_0_22, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("find",417,G__gtrackDict_430_0_23, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("count",553,G__gtrackDict_430_0_24, 107, -1, G__defined_typename("map<int,double,less<int>,allocator<pair<const int,double> > >::size_type"), 0, 1, 1, 1, 8, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("lower_bound",1184,G__gtrackDict_430_0_25, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("upper_bound",1187,G__gtrackDict_430_0_26, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~map<int,double,less<int>,allocator<pair<const int,double> > >", 5846, G__gtrackDict_430_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGInfocLcLGPeak(void) {
   /* GInfo::GPeak */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak));
   G__memfunc_setup("GPeak",456,G__gtrackDict_435_0_1, 105, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__gtrackDict_435_0_2, 85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&GInfo::GPeak::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__gtrackDict_435_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GPeak::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__gtrackDict_435_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&GInfo::GPeak::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__gtrackDict_435_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&GInfo::GPeak::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__gtrackDict_435_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__gtrackDict_435_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GPeak::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__gtrackDict_435_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GPeak::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__gtrackDict_435_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GPeak::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__gtrackDict_435_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GPeak::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("GPeak", 456, G__gtrackDict_435_0_14, (int) ('i'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak), -1, 0, 1, 1, 1, 0, "u 'GInfo::GPeak' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GPeak", 582, G__gtrackDict_435_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__gtrackDict_435_0_16, (int) ('u'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGPeak), -1, 1, 1, 1, 1, 0, "u 'GInfo::GPeak' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGInfocLcLGTrack(void) {
   /* GInfo::GTrack */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack));
   G__memfunc_setup("GTrack",572,G__gtrackDict_436_0_1, 105, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__gtrackDict_436_0_2, 85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&GInfo::GTrack::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__gtrackDict_436_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GTrack::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__gtrackDict_436_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&GInfo::GTrack::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__gtrackDict_436_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&GInfo::GTrack::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__gtrackDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__gtrackDict_436_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__gtrackDict_436_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GTrack::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__gtrackDict_436_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GTrack::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__gtrackDict_436_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&GInfo::GTrack::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__gtrackDict_436_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&GInfo::GTrack::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("GTrack", 572, G__gtrackDict_436_0_14, (int) ('i'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack), -1, 0, 1, 1, 1, 0, "u 'GInfo::GTrack' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GTrack", 698, G__gtrackDict_436_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__gtrackDict_436_0_16, (int) ('u'), G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGTrack), -1, 1, 1, 1, 1, 0, "u 'GInfo::GTrack' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR(void) {
   /* vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("at",213,G__gtrackDict_438_0_1, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__gtrackDict_438_0_2, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__gtrackDict_438_0_3, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__gtrackDict_438_0_4, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__gtrackDict_438_0_5, 117, G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__gtrackDict_438_0_6, 117, G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__gtrackDict_438_0_7, 107, -1, G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__gtrackDict_438_0_8, 107, -1, G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__gtrackDict_438_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__gtrackDict_438_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - sz u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__gtrackDict_438_0_11, 107, -1, G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__gtrackDict_438_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_438_0_13, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_438_0_14, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), G__defined_typename("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >",13412,G__gtrackDict_438_0_15, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >",13412,G__gtrackDict_438_0_16, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 11 '(map<int,double,less<int>,allocator<pair<const int,double> > >)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >",13412,G__gtrackDict_438_0_17, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >",13412,G__gtrackDict_438_0_18, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator' 10 - first u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__gtrackDict_438_0_19, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__gtrackDict_438_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__gtrackDict_438_0_21, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__gtrackDict_438_0_22, 117, G__get_linked_tagnum(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__gtrackDict_438_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__gtrackDict_438_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_438_0_25, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' - 0 - position u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_438_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' - 0 - position u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator' 10 - first "
"u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_438_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' - 0 - position k - 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::size_type' 0 - n "
"u 'map<int,double,less<int>,allocator<pair<const int,double> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__gtrackDict_438_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_438_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_438_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' - 0 - first u 'vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__gtrackDict_438_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >", 13538, G__gtrackDict_438_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR(void) {
   /* vector<GInfo::GSensor,allocator<GInfo::GSensor> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR));
   G__memfunc_setup("at",213,G__gtrackDict_442_0_1, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__gtrackDict_442_0_2, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__gtrackDict_442_0_3, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__gtrackDict_442_0_4, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__gtrackDict_442_0_5, 117, G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR), G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__gtrackDict_442_0_6, 117, G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR), G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__gtrackDict_442_0_7, 107, -1, G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__gtrackDict_442_0_8, 107, -1, G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__gtrackDict_442_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__gtrackDict_442_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - sz u 'GInfo::GSensor' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__gtrackDict_442_0_11, 107, -1, G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__gtrackDict_442_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_442_0_13, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_442_0_14, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), G__defined_typename("vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSensor,allocator<GInfo::GSensor> >",4516,G__gtrackDict_442_0_15, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSensor,allocator<GInfo::GSensor> >",4516,G__gtrackDict_442_0_16, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n u 'GInfo::GSensor' - 11 'GInfo::GSensor()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSensor,allocator<GInfo::GSensor> >",4516,G__gtrackDict_442_0_17, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSensor,allocator<GInfo::GSensor> >",4516,G__gtrackDict_442_0_18, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator' 10 - first u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__gtrackDict_442_0_19, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__gtrackDict_442_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__gtrackDict_442_0_21, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__gtrackDict_442_0_22, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSensor), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__gtrackDict_442_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'GInfo::GSensor' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__gtrackDict_442_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_442_0_25, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' - 0 - position u 'GInfo::GSensor' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_442_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' - 0 - position u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator' 10 - first "
"u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_442_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' - 0 - position k - 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::size_type' 0 - n "
"u 'GInfo::GSensor' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__gtrackDict_442_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_442_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_442_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' - 0 - first u 'vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__gtrackDict_442_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<GInfo::GSensor,allocator<GInfo::GSensor> >", 4642, G__gtrackDict_442_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR(void) {
   /* vector<GInfo::GSlice,allocator<GInfo::GSlice> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR));
   G__memfunc_setup("at",213,G__gtrackDict_446_0_1, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__gtrackDict_446_0_2, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__gtrackDict_446_0_3, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__gtrackDict_446_0_4, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__gtrackDict_446_0_5, 117, G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR), G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__gtrackDict_446_0_6, 117, G__get_linked_tagnum(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR), G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__gtrackDict_446_0_7, 107, -1, G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__gtrackDict_446_0_8, 107, -1, G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__gtrackDict_446_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__gtrackDict_446_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - sz u 'GInfo::GSlice' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__gtrackDict_446_0_11, 107, -1, G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__gtrackDict_446_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_446_0_13, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__gtrackDict_446_0_14, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), G__defined_typename("vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSlice,allocator<GInfo::GSlice> >",4240,G__gtrackDict_446_0_15, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSlice,allocator<GInfo::GSlice> >",4240,G__gtrackDict_446_0_16, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n u 'GInfo::GSlice' - 11 'GInfo::GSlice()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSlice,allocator<GInfo::GSlice> >",4240,G__gtrackDict_446_0_17, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<GInfo::GSlice,allocator<GInfo::GSlice> >",4240,G__gtrackDict_446_0_18, 105, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator' 10 - first u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__gtrackDict_446_0_19, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__gtrackDict_446_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__gtrackDict_446_0_21, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__gtrackDict_446_0_22, 117, G__get_linked_tagnum(&G__gtrackDictLN_GInfocLcLGSlice), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__gtrackDict_446_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'GInfo::GSlice' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__gtrackDict_446_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_446_0_25, 117, G__get_linked_tagnum(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' - 0 - position u 'GInfo::GSlice' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_446_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' - 0 - position u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator' 10 - first "
"u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__gtrackDict_446_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' - 0 - position k - 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::size_type' 0 - n "
"u 'GInfo::GSlice' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__gtrackDict_446_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_446_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__gtrackDict_446_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' - 0 - first u 'vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__gtrackDict_446_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<GInfo::GSlice,allocator<GInfo::GSlice> >", 4366, G__gtrackDict_446_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncgtrackDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalgtrackDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcgtrackDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__gtrackDictLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_TObjArray = { "TObjArray" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_lesslEintgR = { "less<int>" , 115 , -1 };
G__linked_taginfo G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__gtrackDictLN_GInfo = { "GInfo" , 110 , -1 };
G__linked_taginfo G__gtrackDictLN_GInfocLcLGSensor = { "GInfo::GSensor" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_GInfocLcLGSlice = { "GInfo::GSlice" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_allocatorlEpairlEconstsPintcOdoublegRsPgR = { "allocator<pair<const int,double> >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR = { "map<int,double,less<int>,allocator<pair<const int,double> > >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_pairlEintcOdoublegR = { "pair<int,double>" , 115 , -1 };
G__linked_taginfo G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator = { "map<int,double,less<int>,allocator<pair<const int,double> > >::iterator" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLreverse_iterator = { "map<int,double,less<int>,allocator<pair<const int,double> > >::reverse_iterator" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_pairlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiteratorcOboolgR = { "pair<map<int,double,less<int>,allocator<pair<const int,double> > >::iterator,bool>" , 115 , -1 };
G__linked_taginfo G__gtrackDictLN_GInfocLcLGPeak = { "GInfo::GPeak" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_GInfocLcLGTrack = { "GInfo::GTrack" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR = { "vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator = { "vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR = { "vector<GInfo::GSensor,allocator<GInfo::GSensor> >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator = { "vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<GInfo::GSensor,allocator<GInfo::GSensor> >::iterator>" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR = { "vector<GInfo::GSlice,allocator<GInfo::GSlice> >" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator = { "vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator" , 99 , -1 };
G__linked_taginfo G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<GInfo::GSlice,allocator<GInfo::GSlice> >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtablegtrackDict() {
  G__gtrackDictLN_TClass.tagnum = -1 ;
  G__gtrackDictLN_TBuffer.tagnum = -1 ;
  G__gtrackDictLN_TMemberInspector.tagnum = -1 ;
  G__gtrackDictLN_TObject.tagnum = -1 ;
  G__gtrackDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__gtrackDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__gtrackDictLN_TObjArray.tagnum = -1 ;
  G__gtrackDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__gtrackDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__gtrackDictLN_lesslEintgR.tagnum = -1 ;
  G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__gtrackDictLN_GInfo.tagnum = -1 ;
  G__gtrackDictLN_GInfocLcLGSensor.tagnum = -1 ;
  G__gtrackDictLN_GInfocLcLGSlice.tagnum = -1 ;
  G__gtrackDictLN_allocatorlEpairlEconstsPintcOdoublegRsPgR.tagnum = -1 ;
  G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR.tagnum = -1 ;
  G__gtrackDictLN_pairlEintcOdoublegR.tagnum = -1 ;
  G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLreverse_iterator.tagnum = -1 ;
  G__gtrackDictLN_pairlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiteratorcOboolgR.tagnum = -1 ;
  G__gtrackDictLN_GInfocLcLGPeak.tagnum = -1 ;
  G__gtrackDictLN_GInfocLcLGTrack.tagnum = -1 ;
  G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR.tagnum = -1 ;
  G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator.tagnum = -1 ;
  G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR.tagnum = -1 ;
  G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator.tagnum = -1 ;
  G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtablegtrackDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_TClass);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_TBuffer);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_TObject);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_TObjArray);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_lesslEintgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_GInfo),0,-1,262144,(char*)NULL,G__setup_memvarGInfo,G__setup_memfuncGInfo);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_GInfocLcLGSensor),sizeof(GInfo::GSensor),-1,324864,(char*)NULL,G__setup_memvarGInfocLcLGSensor,G__setup_memfuncGInfocLcLGSensor);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_GInfocLcLGSlice),sizeof(GInfo::GSlice),-1,324864,(char*)NULL,G__setup_memvarGInfocLcLGSlice,G__setup_memfuncGInfocLcLGSlice);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_allocatorlEpairlEconstsPintcOdoublegRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR),sizeof(map<int,double,less<int>,allocator<pair<const int,double> > >),-1,298752,(char*)NULL,G__setup_memvarmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR,G__setup_memfuncmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_pairlEintcOdoublegR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_maplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLreverse_iterator);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_pairlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcLcLiteratorcOboolgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_GInfocLcLGPeak),sizeof(GInfo::GPeak),-1,292096,(char*)NULL,G__setup_memvarGInfocLcLGPeak,G__setup_memfuncGInfocLcLGPeak);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_GInfocLcLGTrack),sizeof(GInfo::GTrack),-1,292096,(char*)NULL,G__setup_memvarGInfocLcLGTrack,G__setup_memfuncGInfocLcLGTrack);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR),sizeof(vector<map<int,double,less<int>,allocator<pair<const int,double> > >,allocator<map<int,double,less<int>,allocator<pair<const int,double> > > > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR,G__setup_memfuncvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_reverse_iteratorlEvectorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRcOallocatorlEmaplEintcOdoublecOlesslEintgRcOallocatorlEpairlEconstsPintcOdoublegRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR),sizeof(vector<GInfo::GSensor,allocator<GInfo::GSensor> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR,G__setup_memfuncvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSensorcOallocatorlEGInfocLcLGSensorgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR),sizeof(vector<GInfo::GSlice,allocator<GInfo::GSlice> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR,G__setup_memfuncvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgR);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_vectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__gtrackDictLN_reverse_iteratorlEvectorlEGInfocLcLGSlicecOallocatorlEGInfocLcLGSlicegRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupgtrackDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupgtrackDict()");
  G__set_cpp_environmentgtrackDict();
  G__cpp_setup_tagtablegtrackDict();

  G__cpp_setup_inheritancegtrackDict();

  G__cpp_setup_typetablegtrackDict();

  G__cpp_setup_memvargtrackDict();

  G__cpp_setup_memfuncgtrackDict();
  G__cpp_setup_globalgtrackDict();
  G__cpp_setup_funcgtrackDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncgtrackDict();
  return;
}
class G__cpp_setup_initgtrackDict {
  public:
    G__cpp_setup_initgtrackDict() { G__add_setup_func("gtrackDict",(G__incsetup)(&G__cpp_setupgtrackDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initgtrackDict() { G__remove_setup_func("gtrackDict"); }
};
G__cpp_setup_initgtrackDict G__cpp_setup_initializergtrackDict;

